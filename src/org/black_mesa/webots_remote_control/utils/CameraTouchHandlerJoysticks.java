package org.black_mesa.webots_remote_control.utils;

import java.util.Timer;
import java.util.TimerTask;

import org.black_mesa.webots_remote_control.listeners.CameraTouchHandlerListener;

import android.os.SystemClock;
import android.view.MotionEvent;

/**
 * Handles the touch events on a CameraView.
 * 
 * @author Ilja Kroonen
 */
public class CameraTouchHandlerJoysticks {
	private static final int TIMER_TICK = 32;
	/*
	 * Current state of the handler.
	 */
	private State mState = State.INIT;
	
	/*
	 * Left joystick pointer id and coordinates. Valid in state DOUBLE.
	 */
	private int mRightPointerId;
	private float mRightPointerX;
	private float mRightPointerY;

	/*
	 * Right joystick pointer id and coordinates. Valid in state DOUBLE.
	 */
	private int mLeftPointerId;
	private float mLeftPointerX;
	private float mLeftPointerY;

	/*
	 * Timer used in state DOUBLE.
	 */
	private Timer mTimer;

	/*
	 * Information about the touching surface.
	 */
	private float mXMin;
	private float mYMin;
	private float mXMax;
	private float mYMax;

	/*
	 * Listener for the generated events
	 */
	private CameraTouchHandlerListener mListener;

	/**
	 * Instantiates the CameraTouchHandler.
	 * 
	 * @param xMin
	 *            Start of the x axis of the window.
	 * @param yMin
	 *            Start of the y axis of the window.
	 * @param xMax
	 *            End of the x axis of the window.
	 * @param yMax
	 *            End of the y axis of the window.
	 * @param l
	 *            Listener that will be notified of the actions that need to be
	 *            performed on the camera.
	 */
	public CameraTouchHandlerJoysticks(final float xMin, final float yMin, final float xMax, final float yMax,
			final CameraTouchHandlerListener l) {
		mXMin = xMin;
		mYMin = yMin;
		mXMax = xMax;
		mYMax = yMax;
		mListener = l;
	}

	/**
	 * Has to be called at each touch event on the view.
	 * 
	 * @param event
	 *            MotionEvent that was generated by Android.
	 */
	public final void onTouch(final MotionEvent event) {
		switch (event.getActionMasked()) {
		case MotionEvent.ACTION_DOWN:
			downHandler(event);
			break;
		case MotionEvent.ACTION_CANCEL:
			cancelHandler(event);
			break;
		case MotionEvent.ACTION_UP:
			upHandler(event);
			break;
		case MotionEvent.ACTION_POINTER_DOWN:
			pointerDownHandler(event);
			break;
		case MotionEvent.ACTION_POINTER_UP:
			pointerUpHandler(event);
			break;
		case MotionEvent.ACTION_MOVE:
			moveHandler(event);
			break;
		}
		update(event);
	}

	private void moveHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void pointerUpHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void pointerDownHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void upHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void cancelHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void downHandler(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void timerHandler() {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}

	private void update(final MotionEvent event) {
		switch (mState) {
		case DOUBLE:
			break;
		case INIT:
			break;
		case ONLY_LEFT:
			break;
		case ONLY_RIGHT:
			break;
		}
	}
	
	private enum State {
		DOUBLE, INIT, ONLY_LEFT, ONLY_RIGHT
	}
}